# yaml-language-server: $schema=../state-machine-schema.json
---
name: 'waterfall'
description: 'From Specification down to test – the historical way. Ideal for larger, design-heavy tasks with well-defined requirements'
initial_state: 'requirements'

# Enhanced metadata for better discoverability
metadata:
  domain: 'code'
  complexity: 'high'
  bestFor:
    - 'Large feature development'
    - 'Complex system changes'
    - 'Well-defined requirements'
    - 'Design-heavy projects'
  useCases:
    - 'Building a new module from scratch'
    - 'Implementing complex business logic'
    - 'Major architectural changes'
  examples:
    - 'Create a new authentication system'
    - 'Build a reporting dashboard'
    - 'Implement a payment processing workflow'
  requiresDocumentation: true

# States with default instructions and transitions
states:
  requirements:
    description: 'Gathering and analyzing requirements'
    default_instructions: |
      Make yourself familiar with the code base.
      Focus on understanding their goals, scope, constraints, and success criteria, e. g.
      • Who are the key stakeholders? (end users, business owners, technical teams)
      • Which requirements are must-have vs nice-to-have?
      • How will you measure success? What are the acceptance criteria?
      • What are your time, budget, technical, or regulatory constraints?
      • What existing systems must this integrate with?
      Break down their needs into specific requirements in $REQUIREMENTS_DOC. Plan actionable tasks referencing those requirements in the plan file.
    transitions:
      - trigger: 'requirements_complete'
        to: 'design'
        additional_instructions: 'Requirements are complete! ✅ Now transition to design phase. Mark completed requirements tasks.'
        transition_reason: 'All requirements tasks completed, moving to technical design'
        review_perspectives:
          - perspective: 'business_analyst'
            prompt: 'Review requirements completeness, clarity, and business value. Ensure all stakeholder needs are captured and requirements are testable. Check for missing edge cases or unclear acceptance criteria.'
          - perspective: 'ux_expert'
            prompt: 'Evaluate user experience implications and usability requirements. Ensure user needs and workflows are properly defined. Identify potential UX challenges or accessibility concerns.'

  design:
    description: 'Technical design and architecture planning'
    default_instructions: |
      You are in the design phase. Re-analyze important interfaces of the application.
      Review requirements from $REQUIREMENTS_DOC and design the technical solution
      Focus on HOW to implement what's needed including architecture, technologies, data models, API design, and quality goals.
      Clarify performance expectations and technology preferences if not already obvious from the current analysis.
      Document architectural decisions in $ARCHITECTURE_DOC and detailed design in $DESIGN_DOC. Update the plan file and ensure the approach is solid before implementation."
    transitions:
      - trigger: 'need_more_requirements'
        to: 'requirements'
        additional_instructions: 'Design work revealed gaps in requirements understanding. Focus on clarifying the specific requirements that are blocking design decisions.'
        transition_reason: 'Design work revealed need for additional requirements clarification'

      - trigger: 'design_complete'
        to: 'implementation'
        additional_instructions: 'Design is complete! ✅ Now transition to implementation phase. Mark completed design tasks.'
        transition_reason: 'Technical design is complete, ready for implementation'
        review_perspectives:
          - perspective: 'architect'
            prompt: 'Review technical architecture, design patterns, and system integration. Ensure scalability, maintainability, and alignment with existing systems. Evaluate technology choices and architectural decisions.'
          - perspective: 'security_expert'
            prompt: 'Evaluate security considerations, data protection, and potential vulnerabilities in the proposed design. Review authentication, authorization, data handling, and potential attack vectors.'

  implementation:
    description: 'Building the solution according to design'
    default_instructions: |
      You are in the implementation phase. Follow the architecture from $ARCHITECTURE_DOC and detailed design from $DESIGN_DOC to build the solution. Before starting, clarify the approach:
      • Should this be implemented incrementally or all at once? Any specific order of implementation?
      • Are there high-risk parts that need extra validation or careful implementation?
      Ensure requirements from $REQUIREMENTS_DOC are met. Focus on code structure, error handling, security, and maintainability. Write clean, well-documented code and include basic testing. Update the plan file with implementation progress.
    transitions:
      - trigger: 'need_design_changes'
        to: 'design'
        additional_instructions: "Implementation revealed issues with the current design. Consider what you've learned during coding and adjust the design accordingly. Document the changes and reasons."
        transition_reason: 'Implementation work revealed need to revise the design'

      - trigger: 'need_more_requirements'
        to: 'requirements'
        additional_instructions: 'Implementation revealed gaps in requirements understanding. Focus on clarifying the specific requirements that are blocking implementation.'
        transition_reason: 'Implementation work revealed need for additional requirements'

      - trigger: 'implementation_complete'
        to: 'qa'
        additional_instructions: 'Implementation is complete! ✅ Now transition to quality assurance phase.'
        transition_reason: 'Core implementation is complete, ready for quality assurance'
        review_perspectives:
          - perspective: 'senior_software_developer'
            prompt: 'Review code quality, best practices, and implementation approach. Ensure clean, maintainable, and efficient code. Check for proper error handling, logging, and code organization.'
          - perspective: 'performance_engineer'
            prompt: 'Assess performance implications, resource usage, and potential bottlenecks in the implementation. Review algorithms, data structures, and system resource utilization.'

  qa:
    description: 'Quality assurance and code review'
    default_instructions: 'You are in the quality assurance phase. Take the following specific actions: 1) Syntax Check: Run syntax checking tools or validate syntax manually, 2) Build Project: Build the project to verify it compiles without errors, 3) Run Linter: Execute linting tools to ensure code style consistency, 4) Execute Tests: Run existing tests to verify functionality. Then conduct a multi-perspective code review from security, performance, UX, maintainability, and requirement compliance perspectives. Verify implementation matches $DESIGN_DOC specifications and fulfills the targeted requirements from $REQUIREMENTS_DOC. Update the plan file with QA progress and mark completed tasks.'
    transitions:
      - trigger: 'need_implementation_fixes'
        to: 'implementation'
        additional_instructions: 'Quality assurance revealed issues that require code changes. Focus on the specific problems identified during QA review.'
        transition_reason: 'QA found issues requiring implementation fixes'

      - trigger: 'need_design_changes'
        to: 'design'
        additional_instructions: 'Quality assurance revealed fundamental design issues. Consider the QA findings and adjust the design accordingly.'
        transition_reason: 'QA found issues requiring design changes'

      - trigger: 'qa_complete'
        to: 'testing'
        additional_instructions: 'Quality assurance is complete! ✅ Now transition to testing phase. Mark completed QA tasks.'
        transition_reason: 'Quality assurance is complete, ready for comprehensive testing'

  testing:
    description: 'Comprehensive testing and validation'
    default_instructions: 'You are in the testing phase. Create comprehensive test plans, write and execute tests, validate feature completeness, and ensure everything works as expected. Focus on test coverage, edge cases, integration testing, and user acceptance validation.'
    transitions:
      - trigger: 'need_implementation_fixes'
        to: 'implementation'
        additional_instructions: 'Testing revealed bugs or issues that require code changes. Focus on the specific problems identified during testing.'
        transition_reason: 'Testing found issues requiring implementation fixes'

      - trigger: 'need_qa_review'
        to: 'qa'
        additional_instructions: 'Testing revealed quality issues that need additional QA review. Focus on the specific quality concerns identified.'
        transition_reason: 'Testing found issues requiring additional QA review'

      - trigger: 'testing_complete'
        to: 'finalize'
        additional_instructions: 'Testing is complete! ✅ All tests pass and the feature is validated. Transition to finalization phase. Mark all testing tasks as complete.'
        transition_reason: 'All testing is complete, feature is ready for delivery'
        review_perspectives:
          - perspective: 'business_analyst'
            prompt: 'Verify that all requirements have been met and business objectives are achieved. Ensure the solution delivers the expected business value and meets acceptance criteria.'
          - perspective: 'ux_expert'
            prompt: 'Confirm user experience goals are met and the solution is user-friendly and accessible. Validate that user workflows are intuitive and efficient.'

  finalize:
    description: 'Code cleanup and documentation finalization'
    default_instructions: >
      You are in the finalize phase. This phase ensures code quality and documentation accuracy through systematic cleanup and review.

      **STEP 1: Code Cleanup**
      Systematically clean up development artifacts:

      1. **Remove Debug Output**: Search for and remove all temporary debug output statements used during development.
         Look for language-specific debug output methods (console logging, print statements, debug output functions).
         Remove any debugging statements that were added for development purposes.

      2. **Review TODO/FIXME Comments**:
         - Address each TODO/FIXME comment by either implementing the solution or documenting why it's deferred
         - Remove completed TODOs
         - Convert remaining TODOs to proper issue tracking if needed

      3. **Remove Debugging Code Blocks**:
         - Remove temporary debugging code, test code blocks, and commented-out code
         - Clean up any experimental code that's no longer needed
         - Ensure proper error handling replaces temporary debug logging

      **STEP 2: Documentation Review**
      Review and update documentation to reflect final implementation:

      1. **Update Long-Term Memory Documents**: Based on what was actually implemented:
         • Update $REQUIREMENTS_DOC if requirements changed during development
         • Update $ARCHITECTURE_DOC if architectural decisions evolved
         • Update $DESIGN_DOC if design details were refined or changed
      2. **Compare Against Implementation**: Review documentation against actual implemented functionality
      3. **Update Changed Sections**: Only modify documentation sections that have functional changes
      4. **Remove Development Progress**: Remove references to development iterations, progress notes, and temporary decisions
      5. **Focus on Final State**: Ensure documentation describes the final implemented state, not the development process
      6. **Ask User to Review Document Updates**

      **STEP 3: Final Validation**
      - Run existing tests to ensure cleanup didn't break functionality
      - Verify documentation accuracy with a final review
      - Ensure code is ready for production/delivery

      Update the plan file with finalization progress and mark completed tasks.
    transitions:
      - trigger: 'need_final_changes'
        to: 'implementation'
        additional_instructions: 'Finalization revealed issues that require code changes. Focus on the specific problems identified during final review.'
        transition_reason: 'Final review found issues requiring implementation changes'

      - trigger: 'finalization_complete'
        to: 'requirements'
        additional_instructions: 'Feature is complete and finalized! All work is finished and ready for delivery. Prepare to gather requirements for the next feature or iteration.'
        transition_reason: 'Feature delivery complete, beginning new development cycle'
